###  Load Parameters file  ###
import os
import sys
import numpy as np
from   scipy.interpolate     import griddata
from   scipy.ndimage.filters import gaussian_filter

###  Setup reference point and range ####
# This parameters are only for the curved free surface or fault
# X1 and X2 are the lower and upper range of longitude
# Y1 and Y2 are the lower and upper range of latitude
# Lon_ref and Lat_ref are the reference point (i.e., (0,0) in Cartesian coordinates)
# It is a good choice to set up it as the epicenter.
X1=129.0
X2=133.5
Y1=31.2
Y2=34.7
Lon_ref=130.76
Lat_ref=32.76

# Python path
# Or set up the full path for python manually in your system
sys.path.append('/home/weng/Works/Softwares/Coreform-Cubit-2024.3+46968-Lin64/Coreform-Cubit-2024.3/bin/')

# The in data format is: Lon, Lat, Elevation
#Sur_GRD_data=0           # do not use grid data
Sur_GRD_data=1           # do use grid data
Work_dir      = os.getcwd()
Sur_input_data= Work_dir+"/data/Local_topo.grd"
###  Resample grid interval
grid_size = 10e3
### Smooth parameter
sigma = 10




### Don't need to change the following lines
### -----------------------------------------------------------------------------------------------
Earth_radius = 6371.0
Lon_scale = np.cos(Lat_ref/180.0*3.1415926)*3.1415926*Earth_radius/180.0
Lat_scale = 3.1415926*Earth_radius/180.0

model_name = "surface_sigma_"+str(sigma)+"_inc_"+str(grid_size)
print(model_name)

if( not os.path.exists(Sur_input_data)):
    print("Miss the data for the topo. Please give the correct path to the data...")
    print("Fails to create curved mesh...")
    exit()

if(Sur_GRD_data == 1):
    # Read GRID-format data
    import xarray as xr
    data = xr.open_dataset(Sur_input_data)
    lon  = data['lon'].values.astype(float)
    lat  = data['lat'].values.astype(float)
    z    = data['z'].values.astype(float)
    XYZ  = []
    for i in range(lon.shape[0]):
        for j in range(lat.shape[0]):
            if(lon[i]>=X1 and lon[i]<=X2 and lat[j]>=Y1 and lat[j]<=Y2):
                 XYZ.append([(lon[i]-(Lon_ref))*Lon_scale*1e3, (lat[j]-(Lat_ref))*Lat_scale*1e3, z[i,j]])
    XYZ = np.array(XYZ)
else:
   # Read text data 
    with open(Sur_input_data, 'r') as files:
         content = files.readlines()
    lines=[]
    for line in content:
        if(line[0]=="#"): continue
        lines.append(line.rstrip().split())
    data = np.array(lines,dtype=float)
    XYZ  = np.zeros((data.shape[0],3))
    for i in range(data.shape[0]):
        if(data[i,0]>=X1 and data[i,0]<=X2 and data[i,1]>=Y1 and data[i,1]<=Y2):
             XYZ[i,0] = (data[i,0]-(Lon_ref))*Lon_scale*1e3
             XYZ[i,1] = (data[i,1]-(Lat_ref))*Lat_scale*1e3
             XYZ[i,2] = data[i,2]

X_lower  = np.min(XYZ[:,0])
X_upper  = np.max(XYZ[:,0])
Y_lower  = np.min(XYZ[:,1])
Y_upper  = np.max(XYZ[:,1])
Z_lower  = np.min(XYZ[:,2])
Z_upper  = np.max(XYZ[:,2])
X_dim = int((X_upper-X_lower)/grid_size+1)
Y_dim = int((Y_upper-Y_lower)/grid_size+1)
Z_dim = int((Z_upper-Z_lower)/grid_size+1)
grid_xyz = np.zeros((X_dim,Y_dim,3))


grid_x, grid_y = np.mgrid[X_lower:X_upper:X_dim*1j, Y_lower:Y_upper:Y_dim*1j]
X_Y      = np.column_stack((XYZ[:,0], XYZ[:,1]))
Val      = XYZ[:,2]
grid_val = griddata(X_Y, Val, (grid_x,grid_y), method='nearest')
###  Smooth the data
if(sigma > 0 ):
     grid_val = gaussian_filter(grid_val, sigma, mode='nearest')

grid_xyz[:,:,0] = grid_x[:,:]
grid_xyz[:,:,1] = grid_y[:,:]
grid_xyz[:,:,2] = grid_val[:,:]

print("Finish data processing...")
if(np.isnan(grid_xyz).any()):
    print("There is nan in the grid data. Check the data!!!")
    exit()

#####################################
#####   Create jou file        ######
#####################################
journalFile      = "./CUBIT_jou/"+model_name+".jou"
acisFile         = "../CUBIT_sat/"+model_name+".sat"

j = open(journalFile, 'w')
j.write("# CUBIT journal file generated by interface_netsurf.py.\n" + \
            "#\n" + \
            "# Create an ACIS NURBS surface from intersecting lines.\n" + \
            "#\n" \
            "# ----------------------------------------------------------\n" + \
            "reset\n")
numContours      = grid_xyz.shape[0]
pointsPerContour = grid_xyz.shape[1]
# Loop over contours (u-lines).
for iContour in range(numContours):
    points = grid_xyz[iContour,:,:]
    for iPoint in range(pointsPerContour):
        point = points[iPoint,:]
        j.write("create vertex x %10.5e y %10.5e z %10.5e\n" % \
                    (point[0], point[1], point[2]))
        if 0 == iPoint:
            j.write("${idBeg=Id('vertex')}\n")
    j.write("${idEnd=Id('vertex')}\n")
    j.write("create curve spline vertex {idBeg} to {idEnd} delete\n")
    if 0 == iContour:
        j.write("${idCBeg=Id('curve')}\n")
j.write("${idCEnd=Id('curve')}\n\n")
# Loop over profiles (v-lines).
for iProfile in range(pointsPerContour):
    points = grid_xyz[:,iProfile,:]
    for iPoint in range(numContours):
        point = points[iPoint,:]
        j.write("create vertex x %10.5e y %10.5e z %10.5e\n" % \
                    (point[0], point[1], point[2]))
        if 0 == iPoint:
            j.write("${idBeg=Id('vertex')}\n")
    j.write("${idEnd=Id('vertex')}\n")
    j.write("create curve spline vertex {idBeg} to {idEnd} delete\n")
    if 0 == iProfile:
        j.write("${idPBeg=Id('curve')}\n")
j.write("${idPEnd=Id('curve')}\n\n")
# Create net surface.
j.write("create surface net u curve {idCBeg} to {idCEnd} v curve {idPBeg} to {idPEnd}\n")
# Delete spline curves and export Acis file.
j.write("delete curve all\n")
j.write("export Acis '%s' overwrite\n" % acisFile)
j.close()
print("Finish writing CUBIT journal file...")

#####################################
#####   Create sat file        ######
#####################################
import cubit
print("Init CUBIT...")
try:
    # output all the information to the screen.
    #cubit.init([""])
    # comment all the outout information and warning to the screen.
    cubit.init(["-noecho","-nojournal"])
except:
    pass

input_file = "CUBIT_jou/"+model_name+".jou"
###  Read the CUBIT journal and playback it.
with open(input_file) as f:
    content = f.readlines()
for line in content:
    cubit.cmd(line)
print("Finish CUBIT playback...")


