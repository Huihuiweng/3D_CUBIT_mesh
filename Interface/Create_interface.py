###  Load Parameters file  ###
import os
import sys
import numpy as np
from   scipy.interpolate     import griddata
from   scipy.ndimage.filters import gaussian_filter

###  Setup reference point and range ####
Lon_ref=130.76
Lat_ref=32.76

# Python path
# Or set up the full path for python manually in your system
Work_dir="/home/weng/Works/Softwares/3D_CUBIT_mesh/"
sys.path.append('/home/weng/Works/Softwares/Coreform-Cubit-2024.3+46968-Lin64/Coreform-Cubit-2024.3/bin/')

Int_GRD_data=0           # do not use grid data
#GRD_data=1           # do use grid data
Int_input_data=Work_dir+"/Interface/data/Slip_model_kumamoto.dat"
###  Resample grid interval
grid_size = 1e3
### Smooth parameter
sigma = 10




### Don't need to change the following lines
### -----------------------------------------------------------------------------------------------
Earth_radius = 6371.0
Lon_scale = np.cos(Lat_ref/180.0*3.1415926)*3.1415926*Earth_radius/180.0
Lat_scale = 3.1415926*Earth_radius/180.0

model_name = "slabInterface_sigma_"+str(sigma)+"_inc_"+str(grid_size)
print(model_name)

if( not os.path.exists(Int_input_data)):
    print("Miss the data for the curved fault. Please give the correct path to the data...")
    print("Fails to create curved mesh...")
    exit()

if(Int_GRD_data == 1):
    # Read GRID-format data
    import xarray as xr
    data = xr.open_dataset(Sur_input_data)
    lon  = data['lon'].values.astype(float)
    lat  = data['lat'].values.astype(float)
    z    = data['z'].values.astype(float)
    XYZ  = []
    for i in range(lon.shape[0]):
        for j in range(lat.shape[0]):
            XYZ.append([(lon[i]-(Lon_ref))*Lon_scale*1e3, (lat[j]-(Lat_ref))*Lat_scale*1e3, -z[i,j]*1e3])
    XYZ = np.array(XYZ)
else:
   # Read text data 
    with open(Int_input_data, 'r') as files:
         content = files.readlines()
    lines=[]
    for line in content:
        lines.append(line.rstrip().split(" "))
    data = np.array(lines,dtype=float)
    XYZ  = np.zeros((data.shape[0],3))
    for i in range(data.shape[0]):
        XYZ[i,0] = (data[i,0]-(Lon_ref))*Lon_scale*1e3
        XYZ[i,1] = (data[i,1]-(Lat_ref))*Lat_scale*1e3
        XYZ[i,2] = -data[i,2]*1e3

X_lower  = np.min(XYZ[:,0])
X_upper  = np.max(XYZ[:,0])
Y_lower  = np.min(XYZ[:,1])
Y_upper  = np.max(XYZ[:,1])
Z_lower  = np.min(XYZ[:,2])
Z_upper  = np.max(XYZ[:,2])
X_dim = int((X_upper-X_lower)/grid_size+1)
Y_dim = int((Y_upper-Y_lower)/grid_size+1)
Z_dim = int((Z_upper-Z_lower)/grid_size+1)
grid_xyz = np.zeros((max(X_dim,Y_dim),3,Z_dim))

### Available for non-purely-horizontal fault
### Choose the longest dimension for x axis
if(X_dim > Y_dim):
   grid_str, grid_dip = np.mgrid[X_lower:X_upper:X_dim*1j, Z_lower:Z_upper:Z_dim*1j]
   X_Y  = np.column_stack((XYZ[:,0], XYZ[:,2]))
   Val  = XYZ[:,1]
else:
   grid_str, grid_dip = np.mgrid[Y_lower:Y_upper:Y_dim*1j, Z_lower:Z_upper:Z_dim*1j]
   X_Y  = np.column_stack((XYZ[:,1], XYZ[:,2]))
   Val  = XYZ[:,0]

grid_val = griddata(X_Y, Val, (grid_str,grid_dip), method='nearest')
###  Smooth the data
if(sigma > 0 ):
     grid_val = gaussian_filter(grid_val, sigma, mode='nearest')

for i in range(Z_dim):
    if(X_dim > Y_dim):
        grid_xyz[:,0,i] = grid_str[:,i]
        grid_xyz[:,1,i] = grid_val[:,i]
        grid_xyz[:,2,i] = grid_dip[:,i]
    else:
        grid_xyz[:,0,i] = grid_val[:,i]
        grid_xyz[:,1,i] = grid_str[:,i]
        grid_xyz[:,2,i] = grid_dip[:,i]

print("Finish data processing...")
if(np.isnan(grid_xyz).any()):
    print("There is nan in the grid data. Check the data!!!")
    exit()

#####################################
#####   Create jou file        ######
#####################################
journalFile      = "./CUBIT_jou/"+model_name+".jou"
acisFile         = "../CUBIT_sat/"+model_name+".sat"

j = open(journalFile, 'w')
j.write("# CUBIT journal file generated by interface_netsurf.py.\n" + \
            "#\n" + \
            "# Create an ACIS NURBS surface from intersecting lines.\n" + \
            "#\n" \
            "# ----------------------------------------------------------\n" + \
            "reset\n")
numContours      = grid_xyz.shape[2]
pointsPerContour = grid_xyz.shape[0]
# Loop over contours (u-lines).
for iContour in range(numContours):
    points = grid_xyz[:,:,iContour]
    for iPoint in range(pointsPerContour):
        point = points[iPoint,:]
        j.write("create vertex x %10.5e y %10.5e z %10.5e\n" % \
                    (point[0], point[1], point[2]))
        if 0 == iPoint:
            j.write("${idBeg=Id('vertex')}\n")
    j.write("${idEnd=Id('vertex')}\n")
    j.write("create curve spline vertex {idBeg} to {idEnd} delete\n")
    if 0 == iContour:
        j.write("${idCBeg=Id('curve')}\n")
j.write("${idCEnd=Id('curve')}\n\n")
# Loop over profiles (v-lines).
for iProfile in range(pointsPerContour):
    points = grid_xyz[iProfile,:,:]
    for iPoint in range(numContours):
        point = points[:,iPoint]
        j.write("create vertex x %10.5e y %10.5e z %10.5e\n" % \
                    (point[0], point[1], point[2]))
        if 0 == iPoint:
            j.write("${idBeg=Id('vertex')}\n")
    j.write("${idEnd=Id('vertex')}\n")
    j.write("create curve spline vertex {idBeg} to {idEnd} delete\n")
    if 0 == iProfile:
        j.write("${idPBeg=Id('curve')}\n")
j.write("${idPEnd=Id('curve')}\n\n")
# Create net surface.
j.write("create surface net u curve {idCBeg} to {idCEnd} v curve {idPBeg} to {idPEnd}\n")
# Delete spline curves and export Acis file.
j.write("delete curve all\n")
j.write("export Acis '%s' overwrite\n" % acisFile)
j.close()
print("Finish writing CUBIT journal file...")

#####################################
#####   Create sat file        ######
#####################################
import cubit
print("Init CUBIT...")
try:
    # output all the information to the screen.
    #cubit.init([""])
    # comment all the outout information and warning to the screen.
    cubit.init(["-noecho","-nojournal"])
except:
    pass

input_file = "CUBIT_jou/"+model_name+".jou"
###  Read the CUBIT journal and playback it.
with open(input_file) as f:
    content = f.readlines()
for line in content:
    cubit.cmd(line)
print("Finish CUBIT playback...")


